// This is the build file we use to compile and run Battlecode players.
// We're using Gradle: https://gradle.org/

// Gradle's plugins allow it to automatically generate build scripts
// for different types of code. Here we apply the Java plugin, which provides
// all the tools needed to build player code!

buildscript {
    ext.versions = [
        kotlin: '1.3.61',
        scala: '2.11.7'
    ]
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.61"
    }
    configurations.all {
        // Check for updates every build.
        resolutionStrategy.cacheDynamicVersionsFor 60, 'seconds'
    }
}

plugins {
    //id "org.jetbrains.kotlin.jvm" version "1.3.61"
    //id "scala"
    id "java"
}
apply plugin: 'idea'
apply plugin: 'eclipse'


repositories {
    mavenCentral()
    maven {
        url "https://maven.pkg.github.com/battlecode/battlecode20"
        credentials {
            username = project.findProperty("gpr.user") ?: System.getenv("USERNAME")
            password = project.findProperty("gpr.key") ?: System.getenv("PASSWORD")
        }
    }
    // Use the JCenter repo to resolve Scala dependencies.
    jcenter()
}

// The dependencies of this project.
dependencies {
    compile "org.battlecode:engine20:2020-1.0.1"
    
    // compile "org.jetbrains.kotlin:kotlin-stdlib:$versions.kotlin"

    // Scala!
    // implementation 'org.scala-lang:scala-library:2.11.12'
    // testImplementation 'org.scalatest:scalatest_2.11:3.0.0'
    // testImplementation 'junit:junit:4.12'
}
configurations.all { // Check for updates every build.
    resolutionStrategy.cacheDynamicVersionsFor 60, 'seconds'
}


// Tell gradle that we want Java 8.
sourceCompatibility = 1.8
targetCompatibility = 1.8

// We override Gradle's defaults for project directory layout.
sourceSets {
    main {
        java {
            srcDir file('src')
            outputDir = file("$buildDir/classes")
        }
        // scala.srcDirs = ["src/"]
        // kotlin.srcDirs = ["src/"]
        
        // scala.outputDir = file("$buildDir/classes")
        // kotlin.outputDir = file("$buildDir/classes")
    }

    test {
        // scala.srcDirs = ["test"]
        // kotlin.srcDirs = ["test"]

        java.outputDir = file("$buildDir/tests")
        // scala.outputDir = file("$buildDir/tests")
        // kotlin.outputDir = file("$buildDir/tests")
    }
}

//Setting default output directories for compiled classes and generated replay files
//For other default properties, see gradle.properties
if (!project.hasProperty("classLocation")) {
    ext.classLocation = sourceSets.main.output.classesDirs
}
if (!project.hasProperty("replay")) {
    ext.replay = 'matches/' + project.property('teamA') + '-vs-' + project.property('teamB') + '-on-' + project.property('maps') + '.bc17'
}

// Download a different version of the client depending on the local OS.
def os = System.getProperty("os.name").toLowerCase()
def clientName = os.startsWith('windows') ? 'battlecode-client-win' :
                 os.startsWith('mac') ? 'battlecode-client-mac' :
                 'battlecode-client-linux'

// Eclipse specific setup to enable docs and sources, and configure layout.
eclipse {
    classpath {
        downloadJavadoc = true
        downloadSources = true

        defaultOutputDir = new File(project.buildDir, 'classes-eclipse')
    }
}

// IntelliJ settings.
idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}


// Here we define a task. Tasks like this one, 'unpackClient', can be
// executed in the terminal with `./gradlew unpackClient` in Unix or
// `gradlew unpackClient` in Windows.
/*task updateDistribution(type: Exec) {
    description 'Updates the client and engine'
    group 'battlecode'

    commandLine os.startsWith('windows') ? './pull_dist.bat' : './pull_dist.sh'
}*/

build.group = 'battlecode'
//compileJava.dependsOn('updateDistribution')

// Another task. This one accepts three optional parameters, or "properties",
// corresponding to the bots used by the two teams, and the map(s) used in this
// game. These properties can be set in the command line with:
// On windows:
//   `gradlew -PteamA=<team A bot> -PteamB=<team B bot> -Pmaps=<comma
//   separated list of maps>`
// On OS X and Linux:
//   `./gradlew -PteamA=<team A bot> -PteamB=<team B bot> -Pmaps=<comma
//   separated list of maps>`
task run(type: JavaExec, dependsOn: 'build') {
    description 'Runs a match without starting the client.'
    group 'battlecode'

    main = 'battlecode.server.Main'
    classpath = sourceSets.main.runtimeClasspath
    args = ['-c=-']
    jvmArgs = [
        '-Dbc.server.mode=headless',
        '-Dbc.server.map-path=maps',
        '-Dbc.server.debug=true',
        '-Dbc.engine.debug-methods=true',
        '-Dbc.game.team-a='+project.property('teamA'),
        '-Dbc.game.team-b='+project.property('teamB'),
        '-Dbc.game.team-a.url='+project.property('classLocation'),
        '-Dbc.game.team-b.url='+project.property('classLocation'),
        '-Dbc.game.maps='+project.property('maps'),
        '-Dbc.server.save-file=' + project.property('replay')
    ]
}

// This task prints out all available players, in the format that the `run`
// task expects them to be given as.
task listPlayers {
    description 'Lists all available players.'
    group 'battlecode'

    doLast {
        sourceSets.main.allSource.each {
            println it.name
            if (it.getName().equals('RobotPlayer.java')
                || it.getName().equals('RobotPlayer.kt')
                || it.getName().equals('RobotPlayer.scala')) {
                URI base = new File(project.projectDir, 'src').toURI()
                URI full = it.toURI()
                String path = base.relativize(full).toString()
                println 'PLAYER: '+path.substring(0, path.lastIndexOf('/')).replaceAll('/', '.')
            }
        }
    }
}

// This task prints out all available maps, in the format that the `run` task
// expects them to be given as.
task listMaps {
    description 'Lists all available maps.'
    group 'battlecode'

    doLast {
        sourceSets.main.compileClasspath.each {
            if (it.toString().contains('battlecode-2017')) {
                FileCollection fc = zipTree(it)
                fc += fileTree(new File(project.projectDir, 'maps'))
                fc.each {
                    String fn = it.getName()
                    if (fn.endsWith('.map17')) {
                        println 'MAP: '+fn.substring(0, fn.indexOf('.map17'))
                    }
                }
            }
        }
    }
}

// This task prepares player code for upload, assembling it into a Java archive.
// This archive can be uploaded at `www.battlecode.org`.
/*task jarForUpload(type: Jar) {
    description 'Assembles source code into an archive, ready to be uploaded to the Battlecode site.'
    group 'battlecode'

    from sourceSets.main.scala.srcDirs
    destinationDir = project.projectDir
    archiveName = 'battlecode-player-upload.jar'
}*/